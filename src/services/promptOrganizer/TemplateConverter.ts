/**
 * Template Converter Service
 * Converts between Gemini API response and internal data structures
 */

import type {
  GeneratedTemplate,
  TemplateCandidate,
  ExtractedVariable,
  PromptForOrganization,
} from "@/types/promptOrganizer"
import type { Prompt, VariableConfig, VariableType } from "@/types/prompt"
import { findBestMatch } from "@/utils/stringSimilarity"

/**
 * Template Converter Service
 * Converts Gemini API responses to internal data structures
 */
class TemplateConverter {
  /**
   * Correct corrupted source prompt IDs using fuzzy matching
   * @param sourcePromptIds IDs from Gemini response (potentially corrupted)
   * @param targetPrompts Original prompts with correct IDs
   * @returns Corrected IDs array
   */
  correctSourcePromptIds(
    sourcePromptIds: string[],
    targetPrompts: PromptForOrganization[],
  ): string[] {
    const targetIds = targetPrompts.map((p) => p.id)
    const correctedIds: string[] = []

    for (const corruptedId of sourcePromptIds) {
      // Try exact match first
      if (targetIds.includes(corruptedId)) {
        correctedIds.push(corruptedId)
        continue
      }

      // Try fuzzy match with 90% threshold
      const bestMatch = findBestMatch(corruptedId, targetIds, 90)

      if (bestMatch) {
        console.warn(
          `[ID Correction] Corrected ID: "${corruptedId}" → "${bestMatch.match}" (similarity: ${bestMatch.similarity.toFixed(2)}%)`,
        )
        correctedIds.push(bestMatch.match)
      } else {
        console.warn(
          `[ID Correction] No match found for "${corruptedId}" (keeping as-is)`,
        )
        correctedIds.push(corruptedId)
      }
    }

    return correctedIds
  }

  /**
   * Convert GeneratedTemplate to TemplateCandidate
   *
   * @param generated Template generated by Gemini API
   * @param periodDays Filter period (days)
   * @param targetPrompts Original prompts for ID correction
   * @returns Template candidate for preview
   */
  convertToCandidate(
    generated: GeneratedTemplate,
    periodDays: number,
    targetPrompts: PromptForOrganization[],
  ): TemplateCandidate {
    // Convert ExtractedVariable[] → VariableConfig[]
    const variables = generated.variables.map((v) =>
      this.convertToVariableConfig(v),
    )

    // Correct corrupted IDs
    const correctedIds = this.correctSourcePromptIds(
      generated.sourcePromptIds,
      targetPrompts,
    )

    return {
      id: crypto.randomUUID(),
      title: generated.title,
      content: generated.content,
      useCase: generated.useCase,
      categoryId: generated.categoryId,
      variables,
      aiMetadata: {
        generatedAt: new Date(),
        sourcePromptIds: correctedIds, // Use corrected IDs
        sourceCount: correctedIds.length,
        sourcePeriodDays: periodDays,
        extractedVariables: generated.variables, // Keep original data
        confirmed: false,
        showInPinned: this.shouldShowInPinned(generated),
      },
      userAction: "pending",
    }
  }

  /**
   * Convert ExtractedVariable to VariableConfig
   *
   * @param extracted Variable extracted by Gemini API
   * @returns VariableConfig for existing variable expansion feature
   */
  private convertToVariableConfig(
    extracted: ExtractedVariable,
  ): VariableConfig {
    return {
      name: extracted.name,
      type: this.inferVariableType(extracted),
      defaultValue: "",
    }
  }

  /**
   * Infer variable type
   *
   * @param extracted Extracted variable
   * @returns Inferred variable type
   */
  private inferVariableType(extracted: ExtractedVariable): VariableType {
    const nameLower = extracted.name.toLowerCase()
    const descLower = (extracted.description || "").toLowerCase()

    // Date-related variables
    if (nameLower.includes("date") || nameLower.includes("day")) {
      return "text"
    }

    // Multi-line variables
    if (
      descLower.includes("詳細") ||
      descLower.includes("内容") ||
      descLower.includes("説明") ||
      nameLower.includes("detail") ||
      nameLower.includes("content") ||
      nameLower.includes("description")
    ) {
      return "textarea"
    }

    return "text"
  }

  /**
   * Determine showInPinned flag
   *
   * Criteria:
   * - sourceCount >= 3 (frequently used)
   * - variables.length >= 2 (high versatility)
   *
   * @param generated Generated template
   * @returns Whether to show in Pinned section
   */
  private shouldShowInPinned(generated: GeneratedTemplate): boolean {
    return (
      generated.sourcePromptIds.length >= 3 && generated.variables.length >= 2
    )
  }

  /**
   * Convert TemplateCandidate to Prompt (for saving)
   *
   * @param candidate Template candidate
   * @returns Prompt for saving
   */
  convertToPrompt(candidate: TemplateCandidate): Prompt {
    return {
      id: crypto.randomUUID(),
      name: candidate.title,
      content: candidate.content,
      variables: candidate.variables, // Use VariableConfig[] as is
      executionCount: 0,
      lastExecutedAt: new Date(),
      isPinned: candidate.userAction === "save_and_pin",
      lastExecutionUrl: "",
      createdAt: new Date(),
      updatedAt: new Date(),
      isAIGenerated: true,
      aiMetadata: {
        ...candidate.aiMetadata,
        confirmed: true, // Mark as confirmed when saving
      },
      useCase: candidate.useCase,
      categoryId: candidate.categoryId,
    }
  }
}

export const templateConverter = new TemplateConverter()
